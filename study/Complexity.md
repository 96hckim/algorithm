## 알고리즘 복잡도 표현 방법

### 알고리즘 복잡도 계산 항목

1. **시간 복잡도**: 알고리즘 실행 속도
2. **공간 복잡도**: 알고리즘이 사용하는 메모리 사이즈

### 알고리즘 시간 복잡도의 주요 요소

> 반복문

### 알고리즘 성능 표기법

- Big O (빅-오) 표기법: O(N)

  - 알고리즘 최악의 실행 시간을 표기
  - **가장 많이/일반적으로 사용함**
  - **아무리 최악의 상황이라도, 이정도의 성능은 보장한다는 의미이기 때문**

- Ω (오메가) 표기법: Ω(N)

  - 오메가 표기법은 알고리즘 최상의 실행 시간을 표기

- Θ (세타) 표기법: Θ(N)
  - 오메가 표기법은 알고리즘 평균 실행 시간을 표기

### 대문자 O 표기법

- 빅 오 표기법, Big-O 표기법 이라고도 부름
- O(입력)
  - 입력 n 에 따라 결정되는 시간 복잡도 함수
  - O(1), O($log n$), O(n), O(n$log n$), O($n^2$), O($2^n$), O(n!)등으로 표기함
  - 입력 n 의 크기에 따라 기하급수적으로 시간 복잡도가 늘어날 수 있음 - O(1) < O($log n$) < O(n) < O(n$log n$) < O($n^2$) < O($2^n$) < O(n!) - 참고: log n 의 베이스는 2 - $log_2 n$
    <br><br>
- 단순하게 입력 n에 따라, 몇번 실행이 되는지를 계산하면 됩니다.

  - **표현식에 가장 큰 영향을 미치는 n 의 단위로 표기합니다.**
  - n이 1이든 100이든, 1000이든, 10000이든 실행을

    - 무조건 2회(상수회) 실행한다: O(1)

      ```java
           if (n > 10) {
               System.out.println(n);
           }

      ```

    - n에 따라, n번, n + 10 번, 또는 3n + 10 번등 실행한다: O(n)
      - 다음 코드는 이중 반복문이지만, 상위는 상수로 반복하므로, 3n 실행
      ```java
           for (int num = 0; num < 3; num++) {
               for (int index = 0; index < n; index++) {
                   System.out.println(index)
               }
           }
      ```
    - n에 따라, $n^2$번, $n^2$ + 1000 번, 100$n^2$ - 100, 또는 300$n^2$ + 1번등 실행한다: O($n^2$)
      - 다음 코드는 삼중 반복문이지만, 상위는 상수로 반복하므로, 3$n^2$ 실행
      ```java
           for (int i = 0; i < 3; i++) {
               for (int num = 0; num < n; num++) {
                   for (int index = 0; index < n; index++) {
                           System.out.println(index)
                   }
               }
           }
      ```

<img src="http://www.fun-coding.org/00_Images/bigo.png" width=400/>

- 빅 오 입력값 표기 방법
  - 예:
    - 만약 시간 복잡도 함수가 2$n^2$ + 3n 이라면
      - 가장 높은 차수는 2$n^2$
      - 상수는 실제 큰 영향이 없음
      - 결국 빅 오 표기법으로는 O($n^2$)

#### 시간 복잡도 구하기

- 1부터 n까지의 합을 구하는 알고리즘1
  - 입력 n에 따라 덧셈을 n 번 해야 함 (반복문!)
  - 시간 복잡도: n, 빅 오 표기법으로는 **O(n)**
  ```java
        public int sum(int n) {
            int total = 0;
            for (int i = 1; i <= n; i++) {
                total += i;
            }
            return total;
        }
  ```

* 1부터 n까지의 합을 구하는 알고리즘2
  - 입력 n이 어떻든 간에, 곱셈/덧셈/나눗셈 하면 됨 (반복문이 없음!)
  - 시간 복잡도: 1, 빅 오 표기법으로는 **O(1)**
  ```java
        public int sum(int n) {
          return n * (n + 1) / 2;
        }
  ```

---

# 공간 복잡도

- 프로그램을 실행 및 완료하는데 필요한 저장공간의 양을 뜻함
- 총 필요 저장 공간
  - 고정 공간 (알고리즘과 무관한 공간): 코드 저장 공간, 단순 변수 및 상수
  - 가변 공간 (알고리즘 실행과 관련있는 공간): 실행 중 동적으로 필요한 공간
  - $ S(P) = c + S_p(n) $
    - c: 고정 공간
    - $ S_p(n) $: 가변 공간

> 빅 오 표기법을 생각해볼 때, 고정 공간은 상수이므로 공간 복잡도는 가변 공간예 좌우됨

### 공간 복잡도 예제1

- n! 팩토리얼 구하기
  - n! = 1 x 2 x ... x n
- n의 값에 상관없이 변수 n, 변수 fac, 변수 index 만 필요함
- 공간 복잡도는 O(1)

> 공간 복잡도 계산은 실제 알고리즘 실행시 사용되는 저장공간을 계산하면 됨

```java
public class Factorial {
    public int factorialFunc(int n) {
        int fac = 1;
        for (int index = 2; index < n + 1; index++) {
            fac = fac * index;
        }
        return fac;
    }
}
```

### 공간 복잡도 예제2

- n! 팩토리얼 구하기
  - n! = 1 x 2 x ... x n
- 재귀함수를 사용하였으므로, n에 따라, 변수 n이 n개가 만들어지게 됨
  - factorial 함수를 재귀 함수로 1까지 호출하였을 경우, n부터 1까지 스택에 쌓이게 됨
- 공간 복잡도는 O(n)

```java
public class Factorial {
    public int factorialFunc(int n) {
        if (n > 1) {
            return n * factorialFunc(n - 1);
        } else {
            return 1;
        }
    }
}
```
